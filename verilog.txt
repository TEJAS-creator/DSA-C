// Q3: 4-bit adder/subtractor
module addsub4(A,B,mode,S,cout);
  input [3:0] A,B;
  input mode;  // 0=add, 1=sub
  output [3:0] S;
  output cout;
  wire [3:0] B2;

  assign B2 = B ^ {4{mode}};   // invert B if subtract
  assign {cout,S} = A + B2 + mode;
endmodule



// Q4: 3x3 multiplier using adders and gates
module multiplier3x3(A,B,P);
  input [2:0] A,B;
  output [5:0] P;

  wire [2:0] pp0, pp1, pp2; // partial products
  wire [4:0] sum1, sum2;

  assign pp0 = A & {3{B[0]}};       // A*B0
  assign pp1 = A & {3{B[1]}};       // A*B1
  assign pp2 = A & {3{B[2]}};       // A*B2

  // add pp0, shifted pp1, shifted pp2
  assign sum1 = {pp1,1'b0} + {2'b00,pp0};
  assign sum2 = {pp2,2'b00} + sum1;

  assign P = sum2;
endmodule




// Q1: 4:1 MUX with if-else
module mux4to1_if (I0,I1,I2,I3,sel,Y);
  input I0,I1,I2,I3;
  input [1:0] sel;
  output reg Y;

  always @(*) begin
    if (sel == 2'b00) Y = I0;
    else if (sel == 2'b01) Y = I1;
    else if (sel == 2'b10) Y = I2;
    else Y = I3;
  end
endmodule





// Q2: 8:1 MUX using case
module mux8to1_case(I,sel,Y);
  input [7:0] I;
  input [2:0] sel;
  output reg Y;

  always @(*) begin
    case(sel)
      3'b000: Y = I[0];
      3'b001: Y = I[1];
      3'b010: Y = I[2];
      3'b011: Y = I[3];
      3'b100: Y = I[4];
      3'b101: Y = I[5];
      3'b110: Y = I[6];
      3'b111: Y = I[7];
    endcase
  end
endmodule





// 16:1 mux built from 8:1 and 2:1 mux
module mux16to1(I,sel,Y);
  input [15:0] I;
  input [3:0] sel;
  output Y;
  wire y0,y1;

  mux8to1_case M1(I[7:0], sel[2:0], y0);
  mux8to1_case M2(I[15:8], sel[2:0], y1);
  mux2to1     M3(y0, y1, sel[3], Y);
endmodule






// Q3: 3-bit comparator using logic gates
module comp3bit(A,B,AeqB,AgtB,AltB);
  input [2:0] A,B;
  output AeqB,AgtB,AltB;

  assign AeqB = (A[2]~^B[2]) & (A[1]~^B[1]) & (A[0]~^B[0]);
  assign AgtB = (A[2] & ~B[2]) |
                 ((A[2]~^B[2]) & A[1] & ~B[1]) |
                 ((A[2]~^B[2]) & (A[1]~^B[1]) & A[0] & ~B[0]);
  assign AltB = (~A[2] & B[2]) |
                 ((A[2]~^B[2]) & ~A[1] & B[1]) |
                 ((A[2]~^B[2]) & (A[1]~^B[1]) & ~A[0] & B[0]);
endmodule






// Q4: Binary to Gray converter (N-bit)
module bin2gray #(parameter N=4)(bin,gray);
  input [N-1:0] bin;
  output reg [N-1:0] gray;
  integer i;

  always @(*) begin
    gray[N-1] = bin[N-1];           // MSB same
    for(i=N-2; i>=0; i=i-1) begin
      gray[i] = bin[i+1] ^ bin[i];  // xor neighbors
    end
  end
endmodule




// Q1: 2-to-4 Decoder with active-low enable, active-high outputs
module dec2to4_if(W, En, Y);
  input [1:0] W;
  input En;              // active-low enable
  output reg [3:0] Y;

  always @(*) begin
    if (En == 0) begin
      case(W)
        2'b00: Y = 4'b0001;
        2'b01: Y = 4'b0010;
        2'b10: Y = 4'b0100;
        2'b11: Y = 4'b1000;
      endcase
    end else
      Y = 4'b0000; // disabled
  end
endmodule





// Q2: 4-to-16 Decoder using 2-to-4 decoders
module dec4to16(W, En, Y);
  input [3:0] W;
  input En;               // active-high enable
  output [15:0] Y;

  wire [3:0] en_low;      // enable lines for 4 decoders

  // Top 2-to-4 decoder for MSB (W[3:2]) generates enables (active-low)
  dec2to4_if U0(W[3:2], ~En, en_low);

  // Each sub-decoder handles 4 outputs
  dec2to4_if U1(W[1:0], en_low[0], Y[3:0]);
  dec2to4_if U2(W[1:0], en_low[1], Y[7:4]);
  dec2to4_if U3(W[1:0], en_low[2], Y[11:8]);
  dec2to4_if U4(W[1:0], en_low[3], Y[15:12]);
endmodule





// Q3: 4-to-2 Priority Encoder using casex
module prienc4to2(I,Y,V);
  input [3:0] I;
  output reg [1:0] Y;
  output reg V;

  always @(*) begin
    casex(I)
      4'b1xxx: begin Y=2'b11; V=1; end // I3
      4'b01xx: begin Y=2'b10; V=1; end // I2
      4'b001x: begin Y=2'b01; V=1; end // I1
      4'b0001: begin Y=2'b00; V=1; end // I0
      default: begin Y=2'b00; V=0; end // none
    endcase
  end
endmodule




// Q4: 16-to-4 Priority Encoder using for loop
module prienc16to4(I,Y,V);
  input [15:0] I;
  output reg [3:0] Y;
  output reg V;

  integer k;

  always @(*) begin
    V = 0;
    Y = 4'b0000;
    for(k=15; k>=0; k=k-1) begin
      if(I[k]) begin
        Y = k[3:0];   // assign index of highest '1'
        V = 1;
        disable loop; // break once highest priority found
      end
    end
  end
endmodule





// Q1: Function using 4:1 MUX
module func_mux41(A,B,C,D,F);
  input A,B,C,D;
  output F;
  wire d0,d1,d2,d3;

  assign d0 = (~C) | (~D);
  assign d1 = (~C & D);
  assign d2 = (~C);
  assign d3 = (~D);

  always @(*) begin end // (Vivado requires no empty always, safe here)

  mux4to1 U1(d0,d1,d2,d3,{A,B},F);
endmodule

// 4:1 mux
module mux4to1(I0,I1,I2,I3,sel,Y);
  input I0,I1,I2,I3;
  input [1:0] sel;
  output reg Y;

  always @(*) begin
    case(sel)
      2'b00: Y = I0;
      2'b01: Y = I1;
      2'b10: Y = I2;
      2'b11: Y = I3;
    endcase
  end
endmodule





// Q1: Function using 4:1 MUX
module func_mux41(A,B,C,D,F);
  input A,B,C,D;
  output F;
  wire d0,d1,d2,d3;

  assign d0 = (~C) | (~D);
  assign d1 = (~C & D);
  assign d2 = (~C);
  assign d3 = (~D);

  always @(*) begin end // (Vivado requires no empty always, safe here)

  mux4to1 U1(d0,d1,d2,d3,{A,B},F);
endmodule

// 4:1 mux
module mux4to1(I0,I1,I2,I3,sel,Y);
  input I0,I1,I2,I3;
  input [1:0] sel;
  output reg Y;

  always @(*) begin
    case(sel)
      2'b00: Y = I0;
      2'b01: Y = I1;
      2'b10: Y = I2;
      2'b11: Y = I3;
    endcase
  end
endmodule





// Q3: Function using 4:16 decoder
module func_dec416(a,b,c,d,F);
  input a,b,c,d;
  output F;
  wire [15:0] Y;

  dec4to16 D0({a,b,c,d},1'b1,Y);

  assign F = Y[2] | Y[3] | Y[4] | Y[5] | Y[6] | Y[7] |
             Y[10] | Y[11] | Y[12] | Y[15];
endmodule

// 4:16 decoder
module dec4to16(W,En,Y);
  input [3:0] W;
  input En;
  output reg [15:0] Y;
  integer k;
  always @(*) begin
    if(En) begin
      Y=0;
      Y[W]=1;
    end else Y=0;
  end
endmodule





// Q4: Majority using 2:4 decoder
module majority3(A,B,C,F);
  input A,B,C;
  output F;
  wire [3:0] D;

  dec2to4 D0({A,B},1'b1,D);

  // Majority logic using decoder outputs and C
  assign F = (D[3]) | (D[2] & C) | (D[1] & C);
endmodule

// 2:4 decoder (active-high enable)
module dec2to4(W,En,Y);
  input [1:0] W;
  input En;
  output reg [3:0] Y;
  always @(*) begin
    if(En) begin
      case(W)
        2'b00: Y=4'b0001;
        2'b01: Y=4'b0010;
        2'b10: Y=4'b0100;
        2'b11: Y=4'b1000;
      endcase
    end else
      Y=4'b0000;
  end
endmodule

